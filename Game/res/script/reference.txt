Variables
==========

First byte - opcode

In second byte
	First bit - value (0)/variable (1)
	
	Next two bits - data type
		00 - int
		01 - float
		10 - boolean
		11 - object
	

Third/Fourth bytes - Line number

Last four bytes - data (value/id)



Keywords
==========

set
const

if
else
break

for
while
do		?

function
task			branches, no return value
return

true
false

wait




Data types
==========

int
double
String

object


	// Check for syntax errors
	public void checkTokens(){
		
		// Keep track of brackets
		// { ( [
		int[] brackets = new int[3];
		boolean bracketsChanged;
		
		// Last token
		String last = "";
		
		for(int i = 0; i < tokens.size(); i++){
			
			// Get token
			String token = tokens.get(i);
			char type = getType(token);
			int lineNum = getLineNum(token);
			
			// Get data only
			token = getData(token);
			
			if(i != 0){
				last = tokens.get(i - 1);
				
				char lType = getType(last);
				String lToken = getData(last);				
				
				// Syntax errors if certain tokens were expected
				
				// All keywords should be preceded by ; { or }
				if(type == 'k' && !token.equals("global")){
					if(token.equals("if")){
						if(!lToken.equals("else")){
							compilationError("Expected \"else\"", token, lineNum);
							return;
						}
						continue;
					}
					if(token.equals("const")){
						if(!lToken.equals("set")){
							compilationError("Expected \"set\"", token, lineNum);
							return;
						}
						continue;
					}
					if(token.equals("in")){
						if(lType != 'v'){
							compilationError("Expected variable", token, lineNum);
							return;
						}
						continue;
					}
					if(!lToken.equals(";") && !lToken.equals("{") && !lToken.equals("}")){
						compilationError("Expected ; { or } on previous line", token, lineNum);
						return;
					}
				}
				
				// Variables/functions/literals should not come directly after one another
				else if((type == 'v' || type == 'f' || type == 'i' || type == 'l' || type == 'b' || type == 't') &&
					(lType == 'v' || lType == 'f' || lType == 'i' || lType == 'l' || lType == 'b' || lType == 't')){
					compilationError("Expected operation", token, lineNum);
					return;
				}
				
				// Operators require a value before them
				else if(type == 'o' && !token.equals("++") && !token.equals("--") && !token.equals("!") && lType != 'v' &&
					lType != 'f' && lType != 'i' && lType != 'l' && lType != 'b' && lType != 't' && !lToken.equals(")")){
						compilationError("Expected value", token, lineNum);
						return;
				}
				else if(type == 'o' && (token.equals("++") || token.equals("--")) && lType != 'v'){
					compilationError("Expected variable", token, lineNum);
					return;
				}
				
				// Operators require a value after them
				if(lType == 'o' && !lToken.equals("++") && !lToken.equals("--") && type != 'v' && type != 'f' &&
					type != 'i' && type != 'l' && type != 'b' && type != 't' && !token.equals("(") && !token.equals("!") &&
					!token.equals("global") && !(lToken.contains("=") && !lToken.equals("==") && token.equals("{"))){// Exception for array initializers
						compilationError("Expected value", token, lineNum);
						return;
				}
				
				// Keywords
				if(lType == 'k'){
					switch(lToken){
						case "set":
							if(type != 'v' && !token.equals("const")){
								compilationError("Expected identifier or const", token, lineNum);
								return;
							}
							continue;
						
						case "const": case "global":
							if(type != 'v'){
								compilationError("Expected identifier", token, lineNum);
								return;
							}
							continue;
						
						case "else":
							if(!token.equals("if") && !token.equals("{")){
								compilationError("Expected \"if\" or {", token, lineNum);
								return;
							}
							continue;
						
						case "break":
							if(!token.equals(";")){
								compilationError("Expected ;", token, lineNum);
								return;
							}
							continue;
						
						case "if": case "while": case "for":
							if(!token.equals("(")){
								compilationError("Expected (", token, lineNum);
								return;
							}
							continue;
						
						case "in":
							if(type != 'v' && type != 'f' && type != 'i' && type != 'l'){
								compilationError("Expected numerical value", token, lineNum);
								return;
							}
							continue;
						
						case "function": case "task":
							if(type != 'f'){
								compilationError("Expected " + last + " declaration", token, lineNum);
								return;
							}
							continue;
						
						case "return":
							if(!token.equals(";") && type != 'v' && type != 'f'){
								if(type != 'v' && type != 'f'){
									compilationError("Expected value", token, lineNum);
									return;
								}
								
								compilationError("Expected ;", token, lineNum);
								return;
							}
							continue;
						
						case "wait":
							if(type != 'i' && type != 'l' && type != 'v' && type != 'f'){
								compilationError("Expected value", token, lineNum);
								return;
							}
							continue;
					}
				}
			}
			
			// Check brackets
			bracketsChanged = true;
				 if(token.equals("{"))	brackets[0]++;
			else if(token.equals("}"))	brackets[0]--;
			else if(token.equals("("))	brackets[1]++;
			else if(token.equals(")"))	brackets[1]--;
			else if(token.equals("["))	brackets[2]++;
			else if(token.equals("]"))	brackets[2]--;
			else	 bracketsChanged = false;
			
			if(bracketsChanged){
				for(int j:brackets){
					// If closed before opened or
					// Unclosed at end
					if(j < 0)
						compilationError("Extra close bracket", token, lineNum);
					else if(i == tokens.size() - 1 && j > 0)
						compilationError("Unclosed bracket", token, lineNum);
				}
			}
		}
	}